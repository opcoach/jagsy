/**
 * generated by Xtext 2.12.0
 */
package com.opcoach.bugsy.xtext.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.opcoach.bugsy.xtext.bugsDsl.ArrayID;
import com.opcoach.bugsy.xtext.bugsDsl.ArrayRange;
import com.opcoach.bugsy.xtext.bugsDsl.BugsDslPackage;
import com.opcoach.bugsy.xtext.bugsDsl.BugsModel;
import com.opcoach.bugsy.xtext.bugsDsl.Distribution;
import com.opcoach.bugsy.xtext.bugsDsl.Expression;
import com.opcoach.bugsy.xtext.bugsDsl.For;
import com.opcoach.bugsy.xtext.bugsDsl.Function;
import com.opcoach.bugsy.xtext.bugsDsl.Instruction;
import com.opcoach.bugsy.xtext.bugsDsl.Relation;
import com.opcoach.bugsy.xtext.validation.AbstractBugsDslValidator;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BugsDslValidator extends AbstractBugsDslValidator {
  public final static String CHECK_UNIQUE_VARIABLE_NAME = "uniqueVariableName";
  
  public final static String CHECK_VARIABLE_DIMENSION_COMPLIANCE = "variableDimensionCompliance";
  
  public final static String CHECK_INVALID_INDEX_IN_LOOP = "invalidIndexInLoop";
  
  public final static String CHECK_ARRAY_FUNCTION_ONLY_IN_DATA_BLOCK = "arrayFunctionMustBeUsedOnlyInDataBlock";
  
  /**
   * Check unique name for relations
   */
  @Check
  public void checkUniqueRelationName(final Relation r) {
    final ArrayID nameToCheck = r.getName();
    final EObject parent = r.eContainer();
    if (((parent instanceof BugsModel) || (parent instanceof For))) {
      EList<EObject> _eContents = parent.eContents();
      for (final EObject c : _eContents) {
        if (((!Objects.equal(c, r)) && (c instanceof Relation))) {
          final Relation rc = ((Relation) c);
          boolean _equals = rc.getName().getName().equals(nameToCheck.getName());
          if (_equals) {
            this.warning("Variable names must be unique.", BugsDslPackage.Literals.RELATION__NAME, 
              BugsDslValidator.CHECK_UNIQUE_VARIABLE_NAME);
          }
        }
      }
    }
  }
  
  /**
   * Check dimension compliance for variables in expressions : if a variable is used without indexes, it must be used like this
   */
  @Check
  public void checkDimensionCompliance(final Expression e) {
    final ArrayID id = e.getValue().getId();
    if ((id != null)) {
      EObject _model = this.getModel(e);
      final BugsModel bugsModel = ((BugsModel) _model);
      final int cardinality = id.getIndexes().size();
      Object _verifyCardinalityUsage = this.verifyCardinalityUsage(bugsModel, id.getName(), cardinality);
      boolean _tripleNotEquals = (_verifyCardinalityUsage != null);
      if (_tripleNotEquals) {
        String _name = id.getName();
        String _plus = ("The expression variable " + _name);
        String _plus_1 = (_plus + " is used with different dimensions in the file ");
        this.error(_plus_1, 
          BugsDslPackage.Literals.EXPRESSION__VALUE, BugsDslValidator.CHECK_VARIABLE_DIMENSION_COMPLIANCE);
      }
    }
  }
  
  /**
   * Check dimension compliance for variables in relations : if a variable is used without indexes, it must be used like this
   */
  @Check
  public void checkDimensionCompliance(final Relation r) {
    final int cardinality = r.getName().getIndexes().size();
    final String name = r.getName().getName();
    EObject _model = this.getModel(r);
    final BugsModel bugsModel = ((BugsModel) _model);
    Object _verifyCardinalityUsage = this.verifyCardinalityUsage(bugsModel, name, cardinality);
    boolean _tripleNotEquals = (_verifyCardinalityUsage != null);
    if (_tripleNotEquals) {
      this.error((("The relation variable " + name) + " is used with different dimensions in the file "), 
        BugsDslPackage.Literals.RELATION__NAME, BugsDslValidator.CHECK_VARIABLE_DIMENSION_COMPLIANCE);
    }
  }
  
  @Check
  public void checkArrayIndexIsInScope(final ArrayRange ar) {
    final ArrayList<String> parentScope = this.getVariableNamesInScope(ar);
    this.checkIndexIsInScope(this.getIndexName(ar.getLow()), parentScope);
    this.checkIndexIsInScope(this.getIndexName(ar.getHigh()), parentScope);
  }
  
  /**
   * This method checks operators defined in expression are valid regarding their super ancestor
   * For instance dim and length (array functions) are available only in the data ancestor
   */
  @Check
  public void checkCorrectOperatorsInRelations(final Expression e) {
    if ((this.isInModelPart(e) && (e.getArrayFunction() != null))) {
      String _name = e.getArrayFunction().getOperation().getName();
      String _plus = ("This expression uses an array function ( " + _name);
      String _plus_1 = (_plus + ") which is available only in a data block");
      this.error(_plus_1, 
        BugsDslPackage.Literals.EXPRESSION__ARRAY_FUNCTION, BugsDslValidator.CHECK_ARRAY_FUNCTION_ONLY_IN_DATA_BLOCK);
    }
  }
  
  public void checkIndexIsInScope(final String indexName, final List<String> scope) {
    if ((indexName != null)) {
      boolean _contains = scope.contains(indexName);
      boolean _not = (!_contains);
      if (_not) {
        this.error((("The index variable " + indexName) + " is not defined at this location "), 
          BugsDslPackage.Literals.ARRAY_RANGE__LOW, BugsDslValidator.CHECK_INVALID_INDEX_IN_LOOP);
      }
    }
  }
  
  /**
   * Returns the index name if this is a string or null if it is a string
   */
  public String getIndexName(final String value) {
    if (((value != null) && (!Character.isDigit(value.charAt(0))))) {
      return value;
    }
    return null;
  }
  
  /**
   * This method returns the list of variable names in the scope of current object
   */
  public ArrayList<String> getVariableNamesInScope(final EObject o) {
    ArrayList<String> _xblockexpression = null;
    {
      final ArrayList<String> result = new ArrayList<String>();
      EObject parent = o.eContainer();
      while ((parent != null)) {
        {
          if ((parent instanceof For)) {
            final For forobject = ((For) parent);
            result.add(forobject.getVariable());
          }
          parent = parent.eContainer();
        }
      }
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
  
  /**
   * This method returns the object where  the relation name or expression name in the model is not used using the same cardinality
   *  It returns null if no problem is found
   */
  public Object verifyCardinalityUsage(final BugsModel m, final String name, final int cardinality) {
    EList<Instruction> _instructions = m.getInstructions();
    EList<Instruction> _data = m.getData();
    final Iterable<Instruction> allData = Iterables.<Instruction>concat(_instructions, _data);
    return this.verifyCardinalityUsage(allData, name, cardinality);
  }
  
  public Object verifyCardinalityUsage(final For f, final String name, final int cardinality) {
    return this.verifyCardinalityUsage(f.getInstructions(), name, cardinality);
  }
  
  public Object verifyCardinalityUsage(final Iterable<Instruction> instructions, final String name, final int cardinality) {
    for (final Instruction ins : instructions) {
      {
        final Object check = this.verifyCardinalityUsage(ins, name, cardinality);
        if ((check != null)) {
          return check;
        }
      }
    }
    return null;
  }
  
  public Object verifyCardinalityUsage(final Instruction ins, final String name, final int cardinality) {
    if ((ins instanceof For)) {
      return this.verifyCardinalityUsage(((For) ins), name, cardinality);
    } else {
      if ((ins instanceof Relation)) {
        return this.verifyCardinalityUsage(((Relation) ins), name, cardinality);
      }
    }
    return null;
  }
  
  public Object verifyCardinalityUsage(final Expression e, final String name, final int cardinality) {
    if ((e == null)) {
      return null;
    }
    Function _function = e.getFunction();
    boolean _tripleNotEquals = (_function != null);
    if (_tripleNotEquals) {
      EList<Expression> _params = e.getFunction().getParams();
      for (final Expression p : _params) {
        return this.verifyCardinalityUsage(p, name, cardinality);
      }
    } else {
      Distribution _distribution = e.getDistribution();
      boolean _tripleNotEquals_1 = (_distribution != null);
      if (_tripleNotEquals_1) {
        EList<Expression> _params_1 = e.getDistribution().getParams();
        for (final Expression p_1 : _params_1) {
          return this.verifyCardinalityUsage(p_1, name, cardinality);
        }
      } else {
        if (((e.getValue() != null) && (e.getValue().getId() != null))) {
          ArrayID _verifyCardinalityUsage = this.verifyCardinalityUsage(e.getValue().getId(), name, cardinality);
          boolean _tripleNotEquals_2 = (_verifyCardinalityUsage != null);
          if (_tripleNotEquals_2) {
            return e.getValue();
          }
        } else {
          Object result = this.verifyCardinalityUsage(e.getLeft(), name, cardinality);
          if ((result == null)) {
            result = this.verifyCardinalityUsage(e.getRight(), name, cardinality);
          }
          return result;
        }
      }
    }
    return null;
  }
  
  public Relation verifyCardinalityUsage(final Relation r, final String name, final int cardinality) {
    ArrayID _verifyCardinalityUsage = this.verifyCardinalityUsage(r.getName(), name, cardinality);
    boolean _tripleNotEquals = (_verifyCardinalityUsage != null);
    if (_tripleNotEquals) {
      return r;
    }
    return null;
  }
  
  public ArrayID verifyCardinalityUsage(final ArrayID ai, final String name, final int cardinality) {
    if ((Objects.equal(name, ai.getName()) && (ai.getIndexes().size() != cardinality))) {
      return ai;
    }
    return null;
  }
  
  public EObject getModel(final EObject o) {
    EObject _xblockexpression = null;
    {
      EObject parent = o.eContainer();
      while (((parent != null) && ((parent instanceof BugsModel) == false))) {
        parent = parent.eContainer();
      }
      _xblockexpression = parent;
    }
    return _xblockexpression;
  }
  
  public boolean isInDataPart(final EObject o) {
    return this.isDefinedInAncestorReference(o, BugsDslPackage.eINSTANCE.getBugsModel_Data());
  }
  
  public boolean isInModelPart(final EObject o) {
    return this.isDefinedInAncestorReference(o, BugsDslPackage.eINSTANCE.getBugsModel_Instructions());
  }
  
  public boolean isDefinedInAncestorReference(final EObject o, final EReference parentRef) {
    EObject parent = o.eContainer();
    while ((parent != null)) {
      {
        final EReference ref = parent.eContainmentFeature();
        if (((ref != null) && ref.equals(parentRef))) {
          return true;
        }
        parent = parent.eContainer();
      }
    }
    return false;
  }
}
